# -*- coding: utf-8 -*-
"""mohamed22.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vLt9mIXstiPfW4zZFqasp-ol8pQ3oDQs
"""

from google.colab import drive
drive.mount('/content/drive')

# Assurez-vous que le r√©pertoire contenant my_functions.py est dans le chemin de recherche Python
import sys
sys.path.append('/content/drive/MyDrive/Colab_Notebooks/boite_de_petri') # Exemple si le fichier est dans un dossier sur Drive
 # Exemple si le fichier est dans un dossier sur Drive

!ls "/content/drive/MyDrive/Colab_Notebooks/boite_de_petri"

"""Cette strat√©gie permet de reconstruire la grille compl√®te dans une bo√Æte de P√©tri en s‚Äôappuyant sur :

Une image pr√©trait√©e (grille partiellement d√©tect√©e via Hough Lines) ;

Une grille candidate artificiellement g√©n√©r√©e (ligne horizontales/verticales) ;

Une fonction de fitness : l‚Äôerreur Dice invers√©e (entre masque extrait vs masque virtuel) ;

Une √©volution des candidats pour trouver le meilleur ajustement.

## √âtapes D√©taill√©es pour Coder la Strat√©gie √âvolutionnaire (Optimisation des Param√®tres de Filtre)

Cette section d√©taille le processus de codage de la strat√©gie √©volutionnaire, sp√©cifiquement pour l'optimisation des param√®tres de la grille, comme indiqu√© dans la section "ES-based Filter" du sch√©ma sous "Evolutionary optimization of Filterparameter". L'objectif est de trouver les param√®tres optimaux (rotation, mise √† l'√©chelle, d√©calage vertical, d√©calage horizontal) qui permettent de g√©n√©rer une grille synth√©tique correspondant le mieux √† la grille r√©elle pr√©sente dans l'image pr√©trait√©e.

### √âtape 1 : Pr√©paration de la V√©rit√© Terrain de la Grille (Input pour l'Optimisation)

Avant de lancer l'optimisation √©volutionnaire, il est crucial de disposer d'une repr√©sentation binaire pr√©cise de la grille r√©elle extraite de l'image de la bo√Æte de Petri. Cette image binaire servira de "v√©rit√© terrain" (ground truth) contre laquelle chaque grille candidate g√©n√©r√©e par l'algorithme √©volutionnaire sera compar√©e. Le document d√©crit ce processus dans la section 3.3.1, "Pr√©traitement des bo√Ætes de Petri pour l'√©valuation de la fonction de fitness".

**Objectif :** Obtenir un masque binaire de la grille o√π les lignes de la grille sont repr√©sent√©es par des pixels blancs (valeur 1) et le fond par des pixels noirs (valeur 0).

**D√©tails d'Impl√©mentation :**

1.  **Chargement de l'Image :** Chargez l'image de la bo√Æte de Petri en niveaux de gris.
2.  **Am√©lioration du Contraste :** Appliquez l'√©galisation adaptative de l'histogramme (CLAHE - Contrast Limited Adaptive Histogram Equalization) pour am√©liorer le contraste local, ce qui est particuli√®rement utile pour les images avec des variations d'√©clairage. `cv2.createCLAHE()` et `clahe.apply()` sont les fonctions pertinentes dans OpenCV.
3.  **D√©tection des Bords :** Utilisez l'op√©rateur de Canny (`cv2.Canny()`) pour d√©tecter les bords de la grille. Le choix des seuils bas et haut est critique et peut n√©cessiter un ajustement fin. Le document mentionne la "d√©termination de seuils stables".
4.  **D√©tection des Lignes :** Appliquez la Transform√©e de Hough probabiliste (`cv2.HoughLinesP()`) pour d√©tecter les segments de ligne dans l'image des bords. Cette fonction est plus robuste que la Transform√©e de Hough standard pour les lignes discontinues. Les param√®tres comme `rho`, `theta`, `threshold`, `minLineLength`, et `maxLineGap` devront √™tre ajust√©s.
5.  **Construction du Masque Binaire de Grille :** Dessinez les lignes d√©tect√©es sur une image noire vierge de la m√™me taille que l'originale. Ces lignes formeront votre masque binaire de la grille. Utilisez `cv2.line()` pour dessiner les lignes.
6.  **Op√©rations Morphologiques :** Le document sugg√®re de "fusionner plusieurs bords en une seule ligne plus √©paisse √† l'aide d'op√©rations morphologiques (fermeture)". La fermeture (`cv2.morphologyEx(..., cv2.MORPH_CLOSE)`) peut aider √† connecter les segments de ligne proches et √† √©paissir les lignes de la grille, rendant le masque plus coh√©rent.

**Output de cette √©tape :** Une image NumPy binaire (`np.uint8` ou `np.bool`) repr√©sentant la grille r√©elle, que nous appellerons `ground_truth_grid_mask`.

### √âtape 2 : D√©finition de l'Individu (Candidat de Solution)

Dans le contexte d'un algorithme √©volutionnaire, un "individu" est une solution potentielle au probl√®me d'optimisation. Ici, un individu repr√©sente une configuration de grille d√©finie par un ensemble de param√®tres. Le document sp√©cifie quatre param√®tres mutables pour caract√©riser une grille :

*   **Rotation :** L'angle de rotation de la grille (par exemple, en degr√©s).
*   **Mise √† l'√©chelle (Scale) :** La largeur d'une cellule de grille grav√©e, ce qui influence la densit√© de la grille.
*   **D√©calage Vertical (Offset Y) :** La position verticale de la grille.
*   **D√©calage Horizontal (Offset X) :** La position horizontale de la grille.

**D√©tails d'Impl√©mentation :**

*   **Structure de Donn√©es :** Cr√©ez une classe `Individual` ou une simple structure de donn√©es (par exemple, un dictionnaire ou un `namedtuple`) pour stocker ces quatre param√®tres. Par exemple :
    ```
*   **Plages de Valeurs :** D√©finissez des plages de valeurs r√©alistes pour chaque param√®tre. Ces plages sont cruciales pour l'initialisation al√©atoire et pour contraindre la mutation :
    *   `rotation`: Par exemple, de -45 √† 45 degr√©s (ou 0 √† 360 si la grille peut √™tre compl√®tement invers√©e).
    *   `scale`: Par exemple, de 50 √† 200 pixels (repr√©sentant la taille d'une cellule).
    *   `offset_x`, `offset_y`: Par exemple, de -100 √† 100 pixels (par rapport √† un point de r√©f√©rence central).

### √âtape 3 : Fonction de Fitness

La fonction de fitness est le c≈ìur de l'algorithme √©volutionnaire. Elle quantifie la "qualit√©" de chaque individu en mesurant √† quel point la grille qu'il repr√©sente correspond √† la `ground_truth_grid_mask`. Le document indique que la fitness est le "coefficient de Dice invers√©".

**Objectif :** Calculer une valeur num√©rique qui indique la similarit√© entre une grille g√©n√©r√©e par un individu et la `ground_truth_grid_mask`. Une valeur plus faible indique une meilleure correspondance (car c'est l'inverse du Dice).

**D√©tails d'Impl√©mentation :**

1.  **G√©n√©ration de la Grille Synth√©tique :** Pour un individu donn√©, vous devez g√©n√©rer une image binaire de la grille qu'il repr√©sente en utilisant ses param√®tres (`rotation`, `scale`, `offset_x`, `offset_y`).
    *   Cr√©ez une image noire vierge de la m√™me taille que `ground_truth_grid_mask`.
    *   Calculez les positions des lignes horizontales et verticales de la grille en fonction de `scale` et des `offsets`.
    *   Appliquez la `rotation` √† ces lignes. Vous devrez utiliser des transformations g√©om√©triques (matrices de rotation) pour cela. `cv2.getRotationMatrix2D()` et `cv2.warpAffine()` peuvent √™tre utiles si vous dessinez la grille dans un espace transform√©, ou vous pouvez calculer les coordonn√©es des points de ligne apr√®s rotation.
    *   Dessinez ces lignes sur l'image vierge pour cr√©er `synthetic_grid_mask`.
2.  **Calcul du Coefficient de Dice :** Le coefficient de Dice est une m√©trique de similarit√© entre deux ensembles. Pour deux masques binaires A et B, il est d√©fini comme :
    `Dice(A, B) = (2 * |A ‚à© B|) / (|A| + |B|)`
    o√π `|A ‚à© B|` est le nombre de pixels communs (intersection) et `|A|` et `|B|` sont le nombre total de pixels blancs dans chaque masque (somme des aires).
    *   Convertissez `synthetic_grid_mask` et `ground_truth_grid_mask` en tableaux de bool√©ens ou de 0/1.
    *   Calculez l'intersection : `intersection = np.sum(synthetic_grid_mask * ground_truth_grid_mask)`
    *   Calculez la somme des aires : `sum_of_areas = np.sum(synthetic_grid_mask) + np.sum(ground_truth_grid_mask)`
    *   G√©rez le cas o√π `sum_of_areas` est z√©ro pour √©viter la division par z√©ro (le Dice serait 1 si les deux masques sont vides, ou 0 si l'un est vide et l'autre non).
3.  **Calcul de la Fitness :** La fitness est le coefficient de Dice invers√©. Si vous voulez minimiser la fitness (ce qui est courant dans les algorithmes d'optimisation), alors :
    `fitness = 1 - Dice(synthetic_grid_mask, ground_truth_grid_mask)`
    Une valeur de Dice de 1.0 (correspondance parfaite) donnera une fitness de 0.0 (optimal). Une valeur de Dice de 0.0 (aucune correspondance) donnera une fitness de 1.0 (pire).

### √âtape 4 : Initialisation de la Population

L'algorithme √©volutionnaire commence avec une population d'individus g√©n√©r√©s al√©atoirement. Cette population initiale doit √™tre suffisamment diversifi√©e pour explorer un large √©ventail de solutions potentielles.

**Objectif :** Cr√©er un ensemble d'individus `Individual` avec des param√®tres al√©atoires dans les plages d√©finies.

**D√©tails d'Impl√©mentation :**

1.  **Taille de la Population :** D√©finissez un hyperparam√®tre `POPULATION_SIZE` (par exemple, 50, 100, 200). Une population plus grande peut explorer l'espace de recherche plus efficacement mais n√©cessite plus de calculs par g√©n√©ration.
2.  **G√©n√©ration Al√©atoire :** Pour chaque individu de la population, g√©n√©rez al√©atoirement ses param√®tres (`rotation`, `scale`, `offset_x`, `offset_y`) en utilisant des fonctions de g√©n√©ration de nombres al√©atoires (par exemple, `np.random.uniform()` ou `random.uniform()`) dans les plages sp√©cifi√©es √† l'√âtape 2.
3.  **Calcul de la Fitness Initiale :** Calculez la fitness pour chaque individu de la population initiale en utilisant la fonction de fitness d√©finie √† l'√âtape 3.

### √âtape 5 : Op√©rations √âvolutionnaires (S√©lection, Mutation, Croisement)

Ces op√©rations sont le moteur de l'√©volution de la population. Elles permettent de cr√©er de nouvelles g√©n√©rations d'individus qui, on l'esp√®re, sont de meilleures solutions.

**Objectif :** √Ä partir de la population actuelle, cr√©er une nouvelle population d'individus plus "adapt√©s".

**D√©tails d'Impl√©mentation :**

1.  **S√©lection :** Choisissez les individus les plus performants (ceux avec la meilleure fitness) de la population actuelle pour qu'ils deviennent des "parents" pour la prochaine g√©n√©ration. Des m√©thodes courantes incluent :
    *   **S√©lection par Tournoi :** S√©lectionnez `k` individus au hasard, et le meilleur d'entre eux est choisi. R√©p√©tez pour obtenir le nombre de parents souhait√©.
    *   **S√©lection par Roulette :** La probabilit√© qu'un individu soit s√©lectionn√© est proportionnelle √† sa fitness (ou inversement proportionnelle si vous minimisez la fitness).
    *   **√âlitisme :** Copiez directement les `N` meilleurs individus de la g√©n√©ration actuelle dans la prochaine g√©n√©ration pour garantir que les meilleures solutions ne sont pas perdues.
2.  **Croisement (Crossover) :** Combinez les g√®nes (param√®tres) de deux individus parents pour cr√©er un ou plusieurs "enfants". Le document ne le mentionne pas explicitement mais c'est une op√©ration standard.
    *   **Croisement √† un point :** Choisissez un point al√©atoire et √©changez les param√®tres apr√®s ce point entre les deux parents.
    *   **Croisement uniforme :** Pour chaque param√®tre, choisissez al√©atoirement s'il vient du parent A ou du parent B.
    *   **Croisement arithm√©tique :** Cr√©ez un nouvel enfant en prenant une combinaison lin√©aire des param√®tres des parents (par exemple, `child_param = alpha * parent1_param + (1 - alpha) * parent2_param`).
3.  **Mutation :** Introduisez de petites perturbations al√©atoires dans les param√®tres des individus (enfants ou individus s√©lectionn√©s) pour maintenir la diversit√© g√©n√©tique et √©viter la convergence pr√©matur√©e vers des optima locaux. Le document mentionne sp√©cifiquement la "mutation" comme moyen d'adapter la grille.
    *   **Mutation Gaussienne :** Pour chaque param√®tre d'un individu, ajoutez une petite valeur tir√©e d'une distribution normale (gaussienne) avec une moyenne de 0 et un petit √©cart-type. Assurez-vous que les param√®tres mut√©s restent dans leurs plages valides (par exemple, en les bornant).
    *   **Taux de Mutation :** D√©finissez un `MUTATION_RATE` (par exemple, 0.01 √† 0.1), qui est la probabilit√© qu'un param√®tre donn√© subisse une mutation.

### √âtape 6 : Boucle d'Optimisation (G√©n√©rations)

L'algorithme √©volutionnaire est un processus it√©ratif qui se d√©roule sur plusieurs g√©n√©rations. √Ä chaque g√©n√©ration, la population √©volue vers de meilleures solutions.

**Objectif :** Ex√©cuter l'algorithme sur un nombre d√©fini de g√©n√©rations ou jusqu'√† ce qu'un crit√®re de convergence soit atteint.
"""

!pip install numpy

!pip install -U imagecodecs

!pip install pytorch-lightning

!pip install torchvision

!pip install torch

!pip install torchmetrics

!pip install rglob

!pip install matplotlib

"""‚úÖ √âtape 1 ‚Äî Pr√©traitement de l‚Äôimage r√©elle
Extraire un masque binaire des lignes de grille :

D√©tection du cercle centr√©e et pond√©r√©e.

CLAHE + seuillage binaire avant Canny pour renforcer les lignes.

Fermeture morphologique plus large pour combler les cassures.

D√©tection de lignes avec HoughLinesP plus tol√©rante (lignes plus courtes
accept√©es).
 Dilatation apr√®s la fermeture morphologique pour renforcer les lignes fines.

Seuil de d√©tection abaiss√© dans HoughLinesP pour capter des lignes plus faibles

Affichages debug=True pour comprendre chaque √©tape.

‚úÖ √âtape 2 ‚Äî G√©n√©ration d‚Äôun candidat (solution candidate)
Chaque grille candidate est d√©finie par 4 param√®tres :

rotation: inclinaison globale (en ¬∞)

scaling: espacement entre les lignes

offset_x: d√©calage horizontal

offset_y: d√©calage vertical

Ces param√®tres servent √† dessiner une grille synth√©tique.

‚úÖ √âtape 3 ‚Äî Fonction de fitness (erreur Dice inverse)
Comparer :

mask_extrait ‚Üê celui de extract_grid_mask() ;

mask_candidat ‚Üê grille g√©n√©r√©e avec les 4 param√®tres.

‚úÖ √âtape 4 ‚Äî Strat√©gie √©volutionnaire (ES)
G√©n√©rer une population initiale de candidats al√©atoires ;

√âvaluer chaque candidat avec la fonction de fitness ;

Appliquer des mutations (modification l√©g√®re des 4 param√®tres) ;

Conserver les meilleurs (survie) ;

R√©p√©ter pendant n_iter g√©n√©rations jusqu‚Äô√† convergence.

4. Fonction evolution_strategy() ‚Äî strat√©gie √©volutionnaire

Exemple

Strat√©ger evolutionnaire

√âtape 0 : Importations
"""

import numpy as np
import matplotlib.pyplot as plt
import random
import math
import pandas as pd
import seaborn as sns
import cv2
import os

""" √âtape 1 : G√©n√©ration de Grille Synth√©tique"""

def draw_grid(image_shape, params):
    height, width = image_shape
    rotation = params['rotation']
    scale = params['scale']
    offset_x = params['offset_x']
    offset_y = params['offset_y']
    line_thickness = params['line_thickness']

    center_x, center_y = width // 2, height // 2
    max_dim = int(math.sqrt(width**2 + height**2)) + int(scale * 2)
    temp_grid = np.zeros((max_dim, max_dim), dtype=np.uint8)
    temp_center = max_dim // 2

    for y in range(temp_center - int(height / 2) - int(offset_y),
                   temp_center + int(height / 2) - int(offset_y), max(1, int(scale))):
        cv2.line(temp_grid, (0, y), (max_dim, y), 255, line_thickness)
    for x in range(temp_center - int(width / 2) - int(offset_x),
                   temp_center + int(width / 2) - int(offset_x), max(1, int(scale))):
        cv2.line(temp_grid, (x, 0), (x, max_dim), 255, line_thickness)

    M = cv2.getRotationMatrix2D((temp_center, temp_center), rotation, 1)
    rotated = cv2.warpAffine(temp_grid, M, (max_dim, max_dim), flags=cv2.INTER_NEAREST)

    start_x, start_y = temp_center - center_x, temp_center - center_y
    return rotated[start_y:start_y + height, start_x:start_x + width]

"""√âtape 2 : calcule de fonction Dice"""

def calculate_dice(mask1, mask2):
    intersection = np.sum(mask1 * mask2)
    union = np.sum(mask1) + np.sum(mask2)
    return (2 * intersection) / union if union else 1.0

def fitness(params, target_mask, shape):
    return 1.0 - calculate_dice(draw_grid(shape, params), target_mask)

"""√âtape 3 : D√©tection du Cercle"""

def detect_circle(gray_image):
    """
    D√©tecte le cercle principal (repr√©sentant la bo√Æte de Petri) dans une image en niveaux de gris.
    Cette √©tape est cruciale pour masquer l'image et concentrer le traitement sur la zone pertinente.
    (Figure 3, √©tape 1 du document).

    Args:
        gray_image (numpy.ndarray): Image en niveaux de gris.

    Returns:
        numpy.ndarray or None: Coordonn√©es [x, y, rayon] du cercle d√©tect√©, ou None si aucun cercle n'est trouv√©.
    """
    # Essayer diff√©rentes configurations de flou et de param√®tre param2 pour HoughCircles
    # Cela augmente la robustesse de la d√©tection sous diverses conditions d'√©clairage.
    for blur_ksize in [(9, 9), (7, 7), (5, 5)]:
        blurred = cv2.GaussianBlur(gray_image, blur_ksize, 2)
        # param2 est le seuil de l'accumulateur pour la d√©tection de cercle.
        # Des valeurs plus faibles d√©tectent plus de cercles, mais aussi plus de faux positifs.
        for param2_val in [150, 100, 80, 60]:
            circles = cv2.HoughCircles(blurred, cv2.HOUGH_GRADIENT, 1.2,
                                     minDist=gray_image.shape[0]//4, # Distance minimale entre les centres des cercles d√©tect√©s
                                     param1=100, param2=param2_val,
                                     minRadius=int(0.3*gray_image.shape[0]), # Rayon minimum du cercle (proportionnel √† la hauteur de l'image)
                                     maxRadius=int(0.8*gray_image.shape[0])) # Rayon maximum du cercle
            if circles is not None:
                # Retourne le premier cercle trouv√© (le plus probable)
                return np.uint16(np.around(circles))
    return None

"""√âtape 4 : --- Optimisation √âvolutionnaire ---"""

def evolutionary_grid_optimization(target_mask, shape, generations=100, pop_size=60):

    height, width = shape
    base_scale = height * 0.1  # 10% de la hauteur de l'image

    ranges = {
        'rotation': (-4, 4),
        'scale': (max(10, base_scale * 0.8), base_scale * 1.2),
        'offset_x': (-base_scale, base_scale),
        'offset_y': (-base_scale, base_scale),
        'line_thickness': (1, 2)
    }

    population = [{
        'rotation': random.uniform(*ranges['rotation']),
        'scale': random.uniform(*ranges['scale']),
        'offset_x': random.uniform(*ranges['offset_x']),
        'offset_y': random.uniform(*ranges['offset_y']),
        'line_thickness': random.randint(*ranges['line_thickness'])
    } for _ in range(pop_size)]

    best = None
    best_fit = float('inf')

    for gen in range(generations):


        fits = [(fitness(ind, target_mask, shape), ind) for ind in population]
        fits.sort(key=lambda x: x[0])

        if fits[0][0] < best_fit:
            best_fit, best = fits[0]
            print(f"G√©n√©ration {gen}: Fitness = {1 - best_fit:.4f}, Params = {best}")

        top = [ind for _, ind in fits[:pop_size // 5]]
        population = []
        for _ in range(pop_size):
            parent = random.choice(top)
            child = parent.copy()
            for k in child:
                if random.random() < 0.2:
                    if k == 'line_thickness':
                        child[k] = max(ranges[k][0], min(ranges[k][1], child[k] + random.choice([-1, 1])))
                    else:
                        delta = (ranges[k][1] - ranges[k][0]) * 0.1 * random.uniform(-1, 1)
                        child[k] += delta
                        child[k] = max(ranges[k][0], min(ranges[k][1], child[k]))
            population.append(child)

    print(f"‚úÖ Optimisation termin√©e. Fitness finale = {1 - best_fit:.4f}")
    return best

"""--- √âtape 4 & 5 : Initialisation de la Population et Op√©rations √âvolutionnaires ---

** les √©tapes √† suivre apr√®s la strat√©gie √©volutionnaire (c‚Äôest-√†-dire apr√®s l‚Äôoptimisation des param√®tres de grille) dans le cadre d‚Äôun pipeline complet de traitement d‚Äôimages de bo√Ætes de P√©tri avec grilles grav√©es :**

√âtape 6 ‚Äî G√©n√©ration du masque final
Utiliser les meilleurs param√®tres obtenus par l‚Äôalgorithme √©volutionnaire.

G√©n√©rer un masque binaire de la grille r√©guli√®re optimis√©e (draw_grid()).

Appliquer un masque circulaire pour conserver uniquement la grille √† l'int√©rieur de la bo√Æte de P√©tri.

√âtape 7 ‚Äî Superposition sur l‚Äôimage d‚Äôorigine (Overlay)
Afficher ou sauvegarder une superposition visuelle : grille verte sur image originale.

Permet de valider visuellement la pr√©cision de l‚Äôalignement des lignes.

√âtape 8 ‚Äî Sauvegarde des r√©sultats
Sauvegarder :

le masque final (grid_mask_evolutionary_optimized.png)

√©ventuellement les param√®tres optimis√©s

les figures de validation (overlay, comparaison, etc.)

√âtape 9 ‚Äî (Optionnel) Post-traitement ou segmentation
Le masque de grille peut √™tre utilis√© pour :

Extraire chaque cellule de la grille (segmentation en cases).

Filtrer du bruit ou des r√©gions non pertinentes.

Aligner d'autres donn√©es biologiques sur une grille r√©guli√®re.

√âtape 10 ‚Äî √âvaluation
Mesurer la qualit√© du masque final si la v√©rit√© terrain est disponible.

V√©rifier que la grille d√©tect√©e correspond bien √† la structure physique r√©elle.

Interpr√©ter la valeur finale de fitness :

< 0.1 = bonne

0.1‚Äì0.2 = moyenne

0.2 = insuffisante (mauvais alignement ou convergence locale)

# --- Pipeline Principal de la Strat√©gie √âvolutionnaire ---
# (Correspond au "Testworkflow" de la Figure 2 et au flux g√©n√©ral de la Figure 4)
"""

def grid_evolutionary(image_path):
    img = cv2.imread(image_path)
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
    eq = clahe.apply(gray)

    # 1. D√©tection du cercle
    circles = detect_circle(eq)
    mask_circle = np.zeros_like(gray)
    if circles is not None:
        c = circles[0, 0]
        cv2.circle(mask_circle, (c[0], c[1]), c[2], 255, -1)
    else:
        print("‚ùå Cercle non d√©tect√©")
        return

    # 2. Traitement d‚Äôimage : Canny + morpho + renforcement
    masked = cv2.bitwise_and(eq, eq, mask=mask_circle)
    blur = cv2.GaussianBlur(masked, (5, 5), 0)
    edges = cv2.Canny(blur, 50, 150)
    closed = cv2.morphologyEx(edges, cv2.MORPH_CLOSE, np.ones((5, 5), np.uint8))

    kernel_h = cv2.getStructuringElement(cv2.MORPH_RECT, (20, 1))
    kernel_v = cv2.getStructuringElement(cv2.MORPH_RECT, (1, 20))
    horiz = cv2.morphologyEx(closed, cv2.MORPH_OPEN, kernel_h)
    vert = cv2.morphologyEx(closed, cv2.MORPH_OPEN, kernel_v)
    enhanced = cv2.addWeighted(horiz, 0.5, vert, 0.5, 0)

    # 3. HoughLinesP pour cr√©er le masque cible
    hough_mask = np.zeros_like(gray)
    lines = cv2.HoughLinesP(enhanced, 1, np.pi/180, 15, minLineLength=15, maxLineGap=30)
    if lines is not None:
        for l in lines:
            x1, y1, x2, y2 = l[0]
            angle = np.degrees(np.arctan2(y2 - y1, x2 - x1))
            if -15 <= angle <= 15 or 75 <= abs(angle) <= 105:
                cv2.line(hough_mask, (x1, y1), (x2, y2), 255, 2)
    hough_mask = cv2.bitwise_and(hough_mask, hough_mask, mask=mask_circle)

    # 4. Optimisation √©volutionnaire
    best,best_fit = evolutionary_grid_optimization(hough_mask, gray.shape)
    final_mask = draw_grid(gray.shape, best)
    final_mask = cv2.bitwise_and(final_mask, final_mask, mask=mask_circle)

    # 5. Visualisation des √©tapes
    overlay_1 = cv2.bitwise_and(img, img, mask=mask_circle)
    overlay_5 = cv2.bitwise_and(img, img, mask=final_mask)
    overlay_grid = cv2.cvtColor(final_mask, cv2.COLOR_GRAY2BGR)
    overlay_fitness = np.where(overlay_grid > 0, np.array([0, 255, 0], dtype=np.uint8), img)

    plt.figure(figsize=(12, 8))
    plt.subplot(2, 3, 1); plt.title("1. Cercle d√©tect√©"); plt.imshow(cv2.cvtColor(overlay_1, cv2.COLOR_BGR2RGB)); plt.axis('off')
    plt.subplot(2, 3, 2); plt.title("2. Masque Hough"); plt.imshow(hough_mask, cmap='gray'); plt.axis('off')
    plt.subplot(2, 3, 3); plt.title("3. Grille candidate"); plt.imshow(final_mask, cmap='gray'); plt.axis('off')
    plt.subplot(2, 3, 4); plt.title("4. Superposition"); plt.imshow(cv2.cvtColor(overlay_fitness, cv2.COLOR_BGR2RGB)); plt.axis('off')
    plt.subplot(2, 3, 5); plt.title("5. Grille optimis√©e"); plt.imshow(cv2.cvtColor(overlay_5, cv2.COLOR_BGR2RGB)); plt.axis('off')
    plt.tight_layout()
    plt.show()

"""# --- Exemple d'utilisation ---"""

grid_evolutionary("/content/drive/MyDrive/Colab Notebooks/boite de petri/images/aggregation/MCF10A_DMEMF12-Matrigel_LiquidOverlay-ULA_3000cells_014h_B1_T8_10X.png")

"""Etape :5-La fonctione fitness"""

"""Etape :5-La fonctione fitness"""

import matplotlib.pyplot as plt

# Exemple de donn√©es simul√©es pour fitness au fil des g√©n√©rations (valeurs d√©croissantes simul√©es)
generations = list(range(1, 101))
simulated_fitness = [0.3 * (0.97 ** i) + np.random.uniform(0, 0.005) for i in generations]

# Affichage de la courbe
plt.figure(figsize=(10, 5))
plt.plot(generations, simulated_fitness, label='Fitness (1 - Dice)', color='blue', linewidth=2)
plt.axhline(0.1, color='orange', linestyle='--', label='Seuil acceptable (0.1)')
plt.axhline(0.2, color='red', linestyle='--', label='Mauvais alignement (>0.2)')
plt.xlabel("G√©n√©ration")
plt.ylabel("Fitness (erreur)")
plt.title("√âvolution de la fitness au fil des g√©n√©rations")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

"""üîµ Courbe bleue : la fitness diminue progressivement (am√©lioration de la solution).

üü† Ligne orange (0.1) : seuil en dessous duquel la solution est consid√©r√©e comme bonne.

üî¥ Ligne rouge (0.2) : au-dessus de ce seuil, la grille est g√©n√©ralement inexacte ou brute.
"""

def process_all_images_with_evolutionary_strategy(base_data_path):
    class_folders = ['aggregation', 'monocouche', 'spheroide']
    all_results = []

    for class_folder in class_folders:
        folder_path = os.path.join(base_data_path, class_folder)
        if not os.path.exists(folder_path):
            print(f"Dossier non trouv√©: {folder_path}. Veuillez v√©rifier le chemin.")
            continue

        print(f"\n--- Traitement des images dans le dossier : {class_folder} ---")
        image_files = [f for f in os.listdir(folder_path) if f.lower().endswith(('.png', '.jpg', '.jpeg', '.tif', '.tiff'))]

        if not image_files:
            print(f"Aucune image trouv√©e dans {folder_path}.")
            continue

        for i, image_file in enumerate(image_files):
            image_path = os.path.join(folder_path, image_file)
            best_params, best_fitness, final_mask = grid_evolutionary(image_path, display_plots=False)

            if best_params is not None:
                result_entry = {
                    'image_name': image_file,
                    'class': class_folder,
                    'final_fitness': best_fitness,
                    'final_dice': 1 - best_fitness
                }
                result_entry.update(best_params)
                all_results.append(result_entry)

                mask_filename = f"optimized_grid_{os.path.splitext(image_file)[0]}.png"
                mask_filepath = os.path.join(RESULTS_DIR, mask_filename)
                cv2.imwrite(mask_filepath, final_mask)
                print(f"  Masque optimis√© sauvegard√©: {mask_filepath}")

            print("-" * 60)

    results_df = pd.DataFrame(all_results)
    csv_filepath = os.path.join(RESULTS_DIR, "evolutionary_grid_optimization_results.csv")
    results_df.to_csv(csv_filepath, index=False)
    print(f"\n--- Tous les r√©sultats ont √©t√© sauvegard√©s dans: {csv_filepath} ---")
    print("‚úÖ Strat√©gie √©volutionnaire compl√©t√©e pour toutes les images.")

# --- Lancement ---
if __name__ == '__main__':
    process_all_images_with_evolutionary_strategy(BASE_DATA_PATH)