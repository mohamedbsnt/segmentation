# -*- coding: utf-8 -*-
"""mohamed22.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vLt9mIXstiPfW4zZFqasp-ol8pQ3oDQs
"""

from google.colab import drive
drive.mount('/content/drive')

# Assurez-vous que le répertoire contenant my_functions.py est dans le chemin de recherche Python
import sys
sys.path.append('/content/drive/MyDrive/Colab_Notebooks/boite_de_petri') # Exemple si le fichier est dans un dossier sur Drive
 # Exemple si le fichier est dans un dossier sur Drive

!ls "/content/drive/MyDrive/Colab_Notebooks/boite_de_petri"

"""Cette stratégie permet de reconstruire la grille complète dans une boîte de Pétri en s’appuyant sur :

Une image prétraitée (grille partiellement détectée via Hough Lines) ;

Une grille candidate artificiellement générée (ligne horizontales/verticales) ;

Une fonction de fitness : l’erreur Dice inversée (entre masque extrait vs masque virtuel) ;

Une évolution des candidats pour trouver le meilleur ajustement.

## Étapes Détaillées pour Coder la Stratégie Évolutionnaire (Optimisation des Paramètres de Filtre)

Cette section détaille le processus de codage de la stratégie évolutionnaire, spécifiquement pour l'optimisation des paramètres de la grille, comme indiqué dans la section "ES-based Filter" du schéma sous "Evolutionary optimization of Filterparameter". L'objectif est de trouver les paramètres optimaux (rotation, mise à l'échelle, décalage vertical, décalage horizontal) qui permettent de générer une grille synthétique correspondant le mieux à la grille réelle présente dans l'image prétraitée.

### Étape 1 : Préparation de la Vérité Terrain de la Grille (Input pour l'Optimisation)

Avant de lancer l'optimisation évolutionnaire, il est crucial de disposer d'une représentation binaire précise de la grille réelle extraite de l'image de la boîte de Petri. Cette image binaire servira de "vérité terrain" (ground truth) contre laquelle chaque grille candidate générée par l'algorithme évolutionnaire sera comparée. Le document décrit ce processus dans la section 3.3.1, "Prétraitement des boîtes de Petri pour l'évaluation de la fonction de fitness".

**Objectif :** Obtenir un masque binaire de la grille où les lignes de la grille sont représentées par des pixels blancs (valeur 1) et le fond par des pixels noirs (valeur 0).

**Détails d'Implémentation :**

1.  **Chargement de l'Image :** Chargez l'image de la boîte de Petri en niveaux de gris.
2.  **Amélioration du Contraste :** Appliquez l'égalisation adaptative de l'histogramme (CLAHE - Contrast Limited Adaptive Histogram Equalization) pour améliorer le contraste local, ce qui est particulièrement utile pour les images avec des variations d'éclairage. `cv2.createCLAHE()` et `clahe.apply()` sont les fonctions pertinentes dans OpenCV.
3.  **Détection des Bords :** Utilisez l'opérateur de Canny (`cv2.Canny()`) pour détecter les bords de la grille. Le choix des seuils bas et haut est critique et peut nécessiter un ajustement fin. Le document mentionne la "détermination de seuils stables".
4.  **Détection des Lignes :** Appliquez la Transformée de Hough probabiliste (`cv2.HoughLinesP()`) pour détecter les segments de ligne dans l'image des bords. Cette fonction est plus robuste que la Transformée de Hough standard pour les lignes discontinues. Les paramètres comme `rho`, `theta`, `threshold`, `minLineLength`, et `maxLineGap` devront être ajustés.
5.  **Construction du Masque Binaire de Grille :** Dessinez les lignes détectées sur une image noire vierge de la même taille que l'originale. Ces lignes formeront votre masque binaire de la grille. Utilisez `cv2.line()` pour dessiner les lignes.
6.  **Opérations Morphologiques :** Le document suggère de "fusionner plusieurs bords en une seule ligne plus épaisse à l'aide d'opérations morphologiques (fermeture)". La fermeture (`cv2.morphologyEx(..., cv2.MORPH_CLOSE)`) peut aider à connecter les segments de ligne proches et à épaissir les lignes de la grille, rendant le masque plus cohérent.

**Output de cette étape :** Une image NumPy binaire (`np.uint8` ou `np.bool`) représentant la grille réelle, que nous appellerons `ground_truth_grid_mask`.

### Étape 2 : Définition de l'Individu (Candidat de Solution)

Dans le contexte d'un algorithme évolutionnaire, un "individu" est une solution potentielle au problème d'optimisation. Ici, un individu représente une configuration de grille définie par un ensemble de paramètres. Le document spécifie quatre paramètres mutables pour caractériser une grille :

*   **Rotation :** L'angle de rotation de la grille (par exemple, en degrés).
*   **Mise à l'échelle (Scale) :** La largeur d'une cellule de grille gravée, ce qui influence la densité de la grille.
*   **Décalage Vertical (Offset Y) :** La position verticale de la grille.
*   **Décalage Horizontal (Offset X) :** La position horizontale de la grille.

**Détails d'Implémentation :**

*   **Structure de Données :** Créez une classe `Individual` ou une simple structure de données (par exemple, un dictionnaire ou un `namedtuple`) pour stocker ces quatre paramètres. Par exemple :
    ```
*   **Plages de Valeurs :** Définissez des plages de valeurs réalistes pour chaque paramètre. Ces plages sont cruciales pour l'initialisation aléatoire et pour contraindre la mutation :
    *   `rotation`: Par exemple, de -45 à 45 degrés (ou 0 à 360 si la grille peut être complètement inversée).
    *   `scale`: Par exemple, de 50 à 200 pixels (représentant la taille d'une cellule).
    *   `offset_x`, `offset_y`: Par exemple, de -100 à 100 pixels (par rapport à un point de référence central).

### Étape 3 : Fonction de Fitness

La fonction de fitness est le cœur de l'algorithme évolutionnaire. Elle quantifie la "qualité" de chaque individu en mesurant à quel point la grille qu'il représente correspond à la `ground_truth_grid_mask`. Le document indique que la fitness est le "coefficient de Dice inversé".

**Objectif :** Calculer une valeur numérique qui indique la similarité entre une grille générée par un individu et la `ground_truth_grid_mask`. Une valeur plus faible indique une meilleure correspondance (car c'est l'inverse du Dice).

**Détails d'Implémentation :**

1.  **Génération de la Grille Synthétique :** Pour un individu donné, vous devez générer une image binaire de la grille qu'il représente en utilisant ses paramètres (`rotation`, `scale`, `offset_x`, `offset_y`).
    *   Créez une image noire vierge de la même taille que `ground_truth_grid_mask`.
    *   Calculez les positions des lignes horizontales et verticales de la grille en fonction de `scale` et des `offsets`.
    *   Appliquez la `rotation` à ces lignes. Vous devrez utiliser des transformations géométriques (matrices de rotation) pour cela. `cv2.getRotationMatrix2D()` et `cv2.warpAffine()` peuvent être utiles si vous dessinez la grille dans un espace transformé, ou vous pouvez calculer les coordonnées des points de ligne après rotation.
    *   Dessinez ces lignes sur l'image vierge pour créer `synthetic_grid_mask`.
2.  **Calcul du Coefficient de Dice :** Le coefficient de Dice est une métrique de similarité entre deux ensembles. Pour deux masques binaires A et B, il est défini comme :
    `Dice(A, B) = (2 * |A ∩ B|) / (|A| + |B|)`
    où `|A ∩ B|` est le nombre de pixels communs (intersection) et `|A|` et `|B|` sont le nombre total de pixels blancs dans chaque masque (somme des aires).
    *   Convertissez `synthetic_grid_mask` et `ground_truth_grid_mask` en tableaux de booléens ou de 0/1.
    *   Calculez l'intersection : `intersection = np.sum(synthetic_grid_mask * ground_truth_grid_mask)`
    *   Calculez la somme des aires : `sum_of_areas = np.sum(synthetic_grid_mask) + np.sum(ground_truth_grid_mask)`
    *   Gérez le cas où `sum_of_areas` est zéro pour éviter la division par zéro (le Dice serait 1 si les deux masques sont vides, ou 0 si l'un est vide et l'autre non).
3.  **Calcul de la Fitness :** La fitness est le coefficient de Dice inversé. Si vous voulez minimiser la fitness (ce qui est courant dans les algorithmes d'optimisation), alors :
    `fitness = 1 - Dice(synthetic_grid_mask, ground_truth_grid_mask)`
    Une valeur de Dice de 1.0 (correspondance parfaite) donnera une fitness de 0.0 (optimal). Une valeur de Dice de 0.0 (aucune correspondance) donnera une fitness de 1.0 (pire).

### Étape 4 : Initialisation de la Population

L'algorithme évolutionnaire commence avec une population d'individus générés aléatoirement. Cette population initiale doit être suffisamment diversifiée pour explorer un large éventail de solutions potentielles.

**Objectif :** Créer un ensemble d'individus `Individual` avec des paramètres aléatoires dans les plages définies.

**Détails d'Implémentation :**

1.  **Taille de la Population :** Définissez un hyperparamètre `POPULATION_SIZE` (par exemple, 50, 100, 200). Une population plus grande peut explorer l'espace de recherche plus efficacement mais nécessite plus de calculs par génération.
2.  **Génération Aléatoire :** Pour chaque individu de la population, générez aléatoirement ses paramètres (`rotation`, `scale`, `offset_x`, `offset_y`) en utilisant des fonctions de génération de nombres aléatoires (par exemple, `np.random.uniform()` ou `random.uniform()`) dans les plages spécifiées à l'Étape 2.
3.  **Calcul de la Fitness Initiale :** Calculez la fitness pour chaque individu de la population initiale en utilisant la fonction de fitness définie à l'Étape 3.

### Étape 5 : Opérations Évolutionnaires (Sélection, Mutation, Croisement)

Ces opérations sont le moteur de l'évolution de la population. Elles permettent de créer de nouvelles générations d'individus qui, on l'espère, sont de meilleures solutions.

**Objectif :** À partir de la population actuelle, créer une nouvelle population d'individus plus "adaptés".

**Détails d'Implémentation :**

1.  **Sélection :** Choisissez les individus les plus performants (ceux avec la meilleure fitness) de la population actuelle pour qu'ils deviennent des "parents" pour la prochaine génération. Des méthodes courantes incluent :
    *   **Sélection par Tournoi :** Sélectionnez `k` individus au hasard, et le meilleur d'entre eux est choisi. Répétez pour obtenir le nombre de parents souhaité.
    *   **Sélection par Roulette :** La probabilité qu'un individu soit sélectionné est proportionnelle à sa fitness (ou inversement proportionnelle si vous minimisez la fitness).
    *   **Élitisme :** Copiez directement les `N` meilleurs individus de la génération actuelle dans la prochaine génération pour garantir que les meilleures solutions ne sont pas perdues.
2.  **Croisement (Crossover) :** Combinez les gènes (paramètres) de deux individus parents pour créer un ou plusieurs "enfants". Le document ne le mentionne pas explicitement mais c'est une opération standard.
    *   **Croisement à un point :** Choisissez un point aléatoire et échangez les paramètres après ce point entre les deux parents.
    *   **Croisement uniforme :** Pour chaque paramètre, choisissez aléatoirement s'il vient du parent A ou du parent B.
    *   **Croisement arithmétique :** Créez un nouvel enfant en prenant une combinaison linéaire des paramètres des parents (par exemple, `child_param = alpha * parent1_param + (1 - alpha) * parent2_param`).
3.  **Mutation :** Introduisez de petites perturbations aléatoires dans les paramètres des individus (enfants ou individus sélectionnés) pour maintenir la diversité génétique et éviter la convergence prématurée vers des optima locaux. Le document mentionne spécifiquement la "mutation" comme moyen d'adapter la grille.
    *   **Mutation Gaussienne :** Pour chaque paramètre d'un individu, ajoutez une petite valeur tirée d'une distribution normale (gaussienne) avec une moyenne de 0 et un petit écart-type. Assurez-vous que les paramètres mutés restent dans leurs plages valides (par exemple, en les bornant).
    *   **Taux de Mutation :** Définissez un `MUTATION_RATE` (par exemple, 0.01 à 0.1), qui est la probabilité qu'un paramètre donné subisse une mutation.

### Étape 6 : Boucle d'Optimisation (Générations)

L'algorithme évolutionnaire est un processus itératif qui se déroule sur plusieurs générations. À chaque génération, la population évolue vers de meilleures solutions.

**Objectif :** Exécuter l'algorithme sur un nombre défini de générations ou jusqu'à ce qu'un critère de convergence soit atteint.
"""

!pip install numpy

!pip install -U imagecodecs

!pip install pytorch-lightning

!pip install torchvision

!pip install torch

!pip install torchmetrics

!pip install rglob

!pip install matplotlib

"""✅ Étape 1 — Prétraitement de l’image réelle
Extraire un masque binaire des lignes de grille :

Détection du cercle centrée et pondérée.

CLAHE + seuillage binaire avant Canny pour renforcer les lignes.

Fermeture morphologique plus large pour combler les cassures.

Détection de lignes avec HoughLinesP plus tolérante (lignes plus courtes
acceptées).
 Dilatation après la fermeture morphologique pour renforcer les lignes fines.

Seuil de détection abaissé dans HoughLinesP pour capter des lignes plus faibles

Affichages debug=True pour comprendre chaque étape.

✅ Étape 2 — Génération d’un candidat (solution candidate)
Chaque grille candidate est définie par 4 paramètres :

rotation: inclinaison globale (en °)

scaling: espacement entre les lignes

offset_x: décalage horizontal

offset_y: décalage vertical

Ces paramètres servent à dessiner une grille synthétique.

✅ Étape 3 — Fonction de fitness (erreur Dice inverse)
Comparer :

mask_extrait ← celui de extract_grid_mask() ;

mask_candidat ← grille générée avec les 4 paramètres.

✅ Étape 4 — Stratégie évolutionnaire (ES)
Générer une population initiale de candidats aléatoires ;

Évaluer chaque candidat avec la fonction de fitness ;

Appliquer des mutations (modification légère des 4 paramètres) ;

Conserver les meilleurs (survie) ;

Répéter pendant n_iter générations jusqu’à convergence.

4. Fonction evolution_strategy() — stratégie évolutionnaire

Exemple

Stratéger evolutionnaire

Étape 0 : Importations
"""

import numpy as np
import matplotlib.pyplot as plt
import random
import math
import pandas as pd
import seaborn as sns
import cv2
import os

""" Étape 1 : Génération de Grille Synthétique"""

def draw_grid(image_shape, params):
    height, width = image_shape
    rotation = params['rotation']
    scale = params['scale']
    offset_x = params['offset_x']
    offset_y = params['offset_y']
    line_thickness = params['line_thickness']

    center_x, center_y = width // 2, height // 2
    max_dim = int(math.sqrt(width**2 + height**2)) + int(scale * 2)
    temp_grid = np.zeros((max_dim, max_dim), dtype=np.uint8)
    temp_center = max_dim // 2

    for y in range(temp_center - int(height / 2) - int(offset_y),
                   temp_center + int(height / 2) - int(offset_y), max(1, int(scale))):
        cv2.line(temp_grid, (0, y), (max_dim, y), 255, line_thickness)
    for x in range(temp_center - int(width / 2) - int(offset_x),
                   temp_center + int(width / 2) - int(offset_x), max(1, int(scale))):
        cv2.line(temp_grid, (x, 0), (x, max_dim), 255, line_thickness)

    M = cv2.getRotationMatrix2D((temp_center, temp_center), rotation, 1)
    rotated = cv2.warpAffine(temp_grid, M, (max_dim, max_dim), flags=cv2.INTER_NEAREST)

    start_x, start_y = temp_center - center_x, temp_center - center_y
    return rotated[start_y:start_y + height, start_x:start_x + width]

"""Étape 2 : calcule de fonction Dice"""

def calculate_dice(mask1, mask2):
    intersection = np.sum(mask1 * mask2)
    union = np.sum(mask1) + np.sum(mask2)
    return (2 * intersection) / union if union else 1.0

def fitness(params, target_mask, shape):
    return 1.0 - calculate_dice(draw_grid(shape, params), target_mask)

"""Étape 3 : Détection du Cercle"""

def detect_circle(gray_image):
    """
    Détecte le cercle principal (représentant la boîte de Petri) dans une image en niveaux de gris.
    Cette étape est cruciale pour masquer l'image et concentrer le traitement sur la zone pertinente.
    (Figure 3, étape 1 du document).

    Args:
        gray_image (numpy.ndarray): Image en niveaux de gris.

    Returns:
        numpy.ndarray or None: Coordonnées [x, y, rayon] du cercle détecté, ou None si aucun cercle n'est trouvé.
    """
    # Essayer différentes configurations de flou et de paramètre param2 pour HoughCircles
    # Cela augmente la robustesse de la détection sous diverses conditions d'éclairage.
    for blur_ksize in [(9, 9), (7, 7), (5, 5)]:
        blurred = cv2.GaussianBlur(gray_image, blur_ksize, 2)
        # param2 est le seuil de l'accumulateur pour la détection de cercle.
        # Des valeurs plus faibles détectent plus de cercles, mais aussi plus de faux positifs.
        for param2_val in [150, 100, 80, 60]:
            circles = cv2.HoughCircles(blurred, cv2.HOUGH_GRADIENT, 1.2,
                                     minDist=gray_image.shape[0]//4, # Distance minimale entre les centres des cercles détectés
                                     param1=100, param2=param2_val,
                                     minRadius=int(0.3*gray_image.shape[0]), # Rayon minimum du cercle (proportionnel à la hauteur de l'image)
                                     maxRadius=int(0.8*gray_image.shape[0])) # Rayon maximum du cercle
            if circles is not None:
                # Retourne le premier cercle trouvé (le plus probable)
                return np.uint16(np.around(circles))
    return None

"""Étape 4 : --- Optimisation Évolutionnaire ---"""

def evolutionary_grid_optimization(target_mask, shape, generations=100, pop_size=60):

    height, width = shape
    base_scale = height * 0.1  # 10% de la hauteur de l'image

    ranges = {
        'rotation': (-4, 4),
        'scale': (max(10, base_scale * 0.8), base_scale * 1.2),
        'offset_x': (-base_scale, base_scale),
        'offset_y': (-base_scale, base_scale),
        'line_thickness': (1, 2)
    }

    population = [{
        'rotation': random.uniform(*ranges['rotation']),
        'scale': random.uniform(*ranges['scale']),
        'offset_x': random.uniform(*ranges['offset_x']),
        'offset_y': random.uniform(*ranges['offset_y']),
        'line_thickness': random.randint(*ranges['line_thickness'])
    } for _ in range(pop_size)]

    best = None
    best_fit = float('inf')

    for gen in range(generations):


        fits = [(fitness(ind, target_mask, shape), ind) for ind in population]
        fits.sort(key=lambda x: x[0])

        if fits[0][0] < best_fit:
            best_fit, best = fits[0]
            print(f"Génération {gen}: Fitness = {1 - best_fit:.4f}, Params = {best}")

        top = [ind for _, ind in fits[:pop_size // 5]]
        population = []
        for _ in range(pop_size):
            parent = random.choice(top)
            child = parent.copy()
            for k in child:
                if random.random() < 0.2:
                    if k == 'line_thickness':
                        child[k] = max(ranges[k][0], min(ranges[k][1], child[k] + random.choice([-1, 1])))
                    else:
                        delta = (ranges[k][1] - ranges[k][0]) * 0.1 * random.uniform(-1, 1)
                        child[k] += delta
                        child[k] = max(ranges[k][0], min(ranges[k][1], child[k]))
            population.append(child)

    print(f"✅ Optimisation terminée. Fitness finale = {1 - best_fit:.4f}")
    return best

"""--- Étape 4 & 5 : Initialisation de la Population et Opérations Évolutionnaires ---

** les étapes à suivre après la stratégie évolutionnaire (c’est-à-dire après l’optimisation des paramètres de grille) dans le cadre d’un pipeline complet de traitement d’images de boîtes de Pétri avec grilles gravées :**

Étape 6 — Génération du masque final
Utiliser les meilleurs paramètres obtenus par l’algorithme évolutionnaire.

Générer un masque binaire de la grille régulière optimisée (draw_grid()).

Appliquer un masque circulaire pour conserver uniquement la grille à l'intérieur de la boîte de Pétri.

Étape 7 — Superposition sur l’image d’origine (Overlay)
Afficher ou sauvegarder une superposition visuelle : grille verte sur image originale.

Permet de valider visuellement la précision de l’alignement des lignes.

Étape 8 — Sauvegarde des résultats
Sauvegarder :

le masque final (grid_mask_evolutionary_optimized.png)

éventuellement les paramètres optimisés

les figures de validation (overlay, comparaison, etc.)

Étape 9 — (Optionnel) Post-traitement ou segmentation
Le masque de grille peut être utilisé pour :

Extraire chaque cellule de la grille (segmentation en cases).

Filtrer du bruit ou des régions non pertinentes.

Aligner d'autres données biologiques sur une grille régulière.

Étape 10 — Évaluation
Mesurer la qualité du masque final si la vérité terrain est disponible.

Vérifier que la grille détectée correspond bien à la structure physique réelle.

Interpréter la valeur finale de fitness :

< 0.1 = bonne

0.1–0.2 = moyenne

0.2 = insuffisante (mauvais alignement ou convergence locale)

# --- Pipeline Principal de la Stratégie Évolutionnaire ---
# (Correspond au "Testworkflow" de la Figure 2 et au flux général de la Figure 4)
"""

def grid_evolutionary(image_path):
    img = cv2.imread(image_path)
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
    eq = clahe.apply(gray)

    # 1. Détection du cercle
    circles = detect_circle(eq)
    mask_circle = np.zeros_like(gray)
    if circles is not None:
        c = circles[0, 0]
        cv2.circle(mask_circle, (c[0], c[1]), c[2], 255, -1)
    else:
        print("❌ Cercle non détecté")
        return

    # 2. Traitement d’image : Canny + morpho + renforcement
    masked = cv2.bitwise_and(eq, eq, mask=mask_circle)
    blur = cv2.GaussianBlur(masked, (5, 5), 0)
    edges = cv2.Canny(blur, 50, 150)
    closed = cv2.morphologyEx(edges, cv2.MORPH_CLOSE, np.ones((5, 5), np.uint8))

    kernel_h = cv2.getStructuringElement(cv2.MORPH_RECT, (20, 1))
    kernel_v = cv2.getStructuringElement(cv2.MORPH_RECT, (1, 20))
    horiz = cv2.morphologyEx(closed, cv2.MORPH_OPEN, kernel_h)
    vert = cv2.morphologyEx(closed, cv2.MORPH_OPEN, kernel_v)
    enhanced = cv2.addWeighted(horiz, 0.5, vert, 0.5, 0)

    # 3. HoughLinesP pour créer le masque cible
    hough_mask = np.zeros_like(gray)
    lines = cv2.HoughLinesP(enhanced, 1, np.pi/180, 15, minLineLength=15, maxLineGap=30)
    if lines is not None:
        for l in lines:
            x1, y1, x2, y2 = l[0]
            angle = np.degrees(np.arctan2(y2 - y1, x2 - x1))
            if -15 <= angle <= 15 or 75 <= abs(angle) <= 105:
                cv2.line(hough_mask, (x1, y1), (x2, y2), 255, 2)
    hough_mask = cv2.bitwise_and(hough_mask, hough_mask, mask=mask_circle)

    # 4. Optimisation évolutionnaire
    best,best_fit = evolutionary_grid_optimization(hough_mask, gray.shape)
    final_mask = draw_grid(gray.shape, best)
    final_mask = cv2.bitwise_and(final_mask, final_mask, mask=mask_circle)

    # 5. Visualisation des étapes
    overlay_1 = cv2.bitwise_and(img, img, mask=mask_circle)
    overlay_5 = cv2.bitwise_and(img, img, mask=final_mask)
    overlay_grid = cv2.cvtColor(final_mask, cv2.COLOR_GRAY2BGR)
    overlay_fitness = np.where(overlay_grid > 0, np.array([0, 255, 0], dtype=np.uint8), img)

    plt.figure(figsize=(12, 8))
    plt.subplot(2, 3, 1); plt.title("1. Cercle détecté"); plt.imshow(cv2.cvtColor(overlay_1, cv2.COLOR_BGR2RGB)); plt.axis('off')
    plt.subplot(2, 3, 2); plt.title("2. Masque Hough"); plt.imshow(hough_mask, cmap='gray'); plt.axis('off')
    plt.subplot(2, 3, 3); plt.title("3. Grille candidate"); plt.imshow(final_mask, cmap='gray'); plt.axis('off')
    plt.subplot(2, 3, 4); plt.title("4. Superposition"); plt.imshow(cv2.cvtColor(overlay_fitness, cv2.COLOR_BGR2RGB)); plt.axis('off')
    plt.subplot(2, 3, 5); plt.title("5. Grille optimisée"); plt.imshow(cv2.cvtColor(overlay_5, cv2.COLOR_BGR2RGB)); plt.axis('off')
    plt.tight_layout()
    plt.show()

"""# --- Exemple d'utilisation ---"""

grid_evolutionary("/content/drive/MyDrive/Colab Notebooks/boite de petri/images/aggregation/MCF10A_DMEMF12-Matrigel_LiquidOverlay-ULA_3000cells_014h_B1_T8_10X.png")

"""Etape :5-La fonctione fitness"""

"""Etape :5-La fonctione fitness"""

import matplotlib.pyplot as plt

# Exemple de données simulées pour fitness au fil des générations (valeurs décroissantes simulées)
generations = list(range(1, 101))
simulated_fitness = [0.3 * (0.97 ** i) + np.random.uniform(0, 0.005) for i in generations]

# Affichage de la courbe
plt.figure(figsize=(10, 5))
plt.plot(generations, simulated_fitness, label='Fitness (1 - Dice)', color='blue', linewidth=2)
plt.axhline(0.1, color='orange', linestyle='--', label='Seuil acceptable (0.1)')
plt.axhline(0.2, color='red', linestyle='--', label='Mauvais alignement (>0.2)')
plt.xlabel("Génération")
plt.ylabel("Fitness (erreur)")
plt.title("Évolution de la fitness au fil des générations")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

"""🔵 Courbe bleue : la fitness diminue progressivement (amélioration de la solution).

🟠 Ligne orange (0.1) : seuil en dessous duquel la solution est considérée comme bonne.

🔴 Ligne rouge (0.2) : au-dessus de ce seuil, la grille est généralement inexacte ou brute.
"""

def process_all_images_with_evolutionary_strategy(base_data_path):
    class_folders = ['aggregation', 'monocouche', 'spheroide']
    all_results = []

    for class_folder in class_folders:
        folder_path = os.path.join(base_data_path, class_folder)
        if not os.path.exists(folder_path):
            print(f"Dossier non trouvé: {folder_path}. Veuillez vérifier le chemin.")
            continue

        print(f"\n--- Traitement des images dans le dossier : {class_folder} ---")
        image_files = [f for f in os.listdir(folder_path) if f.lower().endswith(('.png', '.jpg', '.jpeg', '.tif', '.tiff'))]

        if not image_files:
            print(f"Aucune image trouvée dans {folder_path}.")
            continue

        for i, image_file in enumerate(image_files):
            image_path = os.path.join(folder_path, image_file)
            best_params, best_fitness, final_mask = grid_evolutionary(image_path, display_plots=False)

            if best_params is not None:
                result_entry = {
                    'image_name': image_file,
                    'class': class_folder,
                    'final_fitness': best_fitness,
                    'final_dice': 1 - best_fitness
                }
                result_entry.update(best_params)
                all_results.append(result_entry)

                mask_filename = f"optimized_grid_{os.path.splitext(image_file)[0]}.png"
                mask_filepath = os.path.join(RESULTS_DIR, mask_filename)
                cv2.imwrite(mask_filepath, final_mask)
                print(f"  Masque optimisé sauvegardé: {mask_filepath}")

            print("-" * 60)

    results_df = pd.DataFrame(all_results)
    csv_filepath = os.path.join(RESULTS_DIR, "evolutionary_grid_optimization_results.csv")
    results_df.to_csv(csv_filepath, index=False)
    print(f"\n--- Tous les résultats ont été sauvegardés dans: {csv_filepath} ---")
    print("✅ Stratégie évolutionnaire complétée pour toutes les images.")

# --- Lancement ---
if __name__ == '__main__':
    process_all_images_with_evolutionary_strategy(BASE_DATA_PATH)